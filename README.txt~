Geometría Computacional
Práctica 02 Parte 2 DCEL
Autor: Gaspar Bautista Miguel Angel
Número de cuenta: 30613413-5


Las funciones que se implementaron son:
incident_he_to_v(): dado que la estructura vertex nos proporciona el apuntador hacía la arista de la
cual es punto inicial, obtenemos esa arista y la metemos a la lista que despues devolveremos,
Lo que hice fue guardar la arista que agregue primero y sólamente en un while checo que la arista
gemela de la arista gemela no sea igual a la arista que guarde utilizando la funcion que nos proporcionas half_edge_equals() y vamos agregando a la lista las aristas que son incidentes del vertice, paramos 
hasta que se cumpla la igualdad de aristas.
Finalmente devolvemos la lista de aristas.

incident_f_to_f(): primero obtenemos todas las aristas que son incidentes a la cara que nos pasan, 
despues construimos un rb_tree y checamos que la cara del gemelo de cada arista, si la cara esta en el arbol
ya seguimos con la otra arista, si la cara no está en el arbol entonces la agregamos al arbol, finalmente
devolvemos la lista que resulta al usar la funcion rb_tree_to_list().

he_from_f(): esta función nos regresa todas las aristas que conforman el contorno de una cara, pero sólamente
con el atributo outer_component que nos brinda la cara.

incident_he_to_f(): esta funcion utiliza la funcion auxiliar he_from_f() solamente para el atributo outer_component de una cara, si el atributo inner_components de la cara que recibe la función es NULL
solamente regresa el resultado de he_from_f, si no es NULL regresa las incidencias de cada elemento de 
inner_components, y las agrega a la lista resultante. 

